# 外部迭代和内部迭代

外部迭代为客户端提供了一种枚举集合中的每个元素的方式，客户端使用这种方式顺序地便利集合的元素。如：

```java
for (Shape s : shapes) {
    s.setColor(RED);
}
```

外部跌内存在几个问题：
* 内省是串行的，需要按照集合指定的顺序处理每个元素
* 它剥夺了库方法管理控制流程的机会，它可能使用数据的重排序，并行性，短路或延迟来提高性能。

有时for-each循环的严格规范是可取的，但有时它可能是性能的障碍。


外部的迭代的替代是内部迭代，先比较与控制迭代，客户端将它委托给库并传递代码片段，在计算的各个点执行。

之前例子的相等的内部迭代的写法：

```java
shapes.forEach(s -> {s.setColor(RED);});
```


这种方式将控制流程管理从客户代码移到库代码中，不仅使得库可以抽象常用控制流操作，也使得它们能够存在使用laziness，parallelism和无序指定来提高性能。虽然这些是由forEach的实现来决定，但起码提供了实现的可能性。

内部迭代为它自己提供了一种编程风格，这种风格里可以以流水线地方式结合在一起。比如：
```java
shapes.stream()
      .filter(s -> s.getColor() == BLUE)
      .forEach(s -> { s.setColor(RED); });
```

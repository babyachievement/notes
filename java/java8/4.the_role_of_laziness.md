# laziness的角色

像filter或者map这样的操作可以“踊跃地”（eagerly）（在filter方法返回时完成过滤）执行，或者“懒惰地”（lazily）（在迭代filter方法的结果中的元素时过滤）。产生新stream的Stream操作，比如filter或者map，为它们提供了“懒惰”实现，它们往往会产生重要的性能提升。而那些聚合或者有副作用的操作如将结果dump到一个集合中或者对每个元素做些什么的操作是“天然积极的”。（naturally eager）

Based on examination of many existing loops, a significant proportion can be restated as bulk operations drawing from a data source (array or collection), doing a series of lazy operations (filtering, mapping, etc), and then doing a single eager operation -- such as filter-map-accumulate, filter-map-sort-foreach, etc. Accordingly, most of the naturally lazy operations tend to be used to compute temporary intermediate results, and we can exploit this property to produce more efficient libraries. (For example, a library that does filtering or mapping lazily can fuse pipelines like filter-map-accumulate into a single pass on the data, rather than three distinct passes; a library that does them eagerly cannot. Similarly, if we are looking for the first element that matches a certain characteristic, a lazy approach lets us get to the answer having examined fewer elements.)

This observation informs a critical design choice: what should the return type of filter and map be? One candidate would be that List.filter returns a new List, which would push us towards an all-eager approach. This is straightforward, but may well end up doing way more work than we really need. Another approach would be to create a whole new set of abstractions for explicit laziness -- LazyList, LazySet, etc. (But note that lazy collections would probably still have operations that trigger eager computation -- such as size.) And, this approach has the risk to devolve into a combinatorial explosion of types like MutableSynchronizedLazySortedSet, etc.

Our preferred approach is to treat the naturally-lazy operations as returning a stream rather than a new collection (which might just get thrown away by the next pipeline stage anyway). Applying this to the examples above, filter draws from a source and produces a stream of values matching the provided Predicate. In most cases where potentially-lazy operations are being applied to aggregates, this turns out to be exactly what we want -- a stream of values that can be passed to the next stage in the pipeline.

The stream approach has the advantage that, when used in a source-lazy-lazy-eager pipeline, the laziness is mostly invisible, as the pipeline is "sealed" at both ends with instantiated data structures, but yields both good usability and performance without dramatically increasing the conceptual surface area of the library.


[lambda](http://cr.openjdk.java.net/~briangoetz/lambda/sotc3.html)